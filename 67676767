-- 1509
Config = {
    api = "c1d8e411-3771-4b0c-8989-24adfff9549a",
    service = "Key system FTF",
    provider = "Key system"
}
local function main()
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")

local LocalPlayer = Players.LocalPlayer

task.spawn(function()
    local a1 = "https://disc"
    local a2 = "ord.com/api/"
    local a3 = "web"
    local a4 = "hooks/"
    local a5 = "13974146778"
    local a6 = "43021854/"
    local a7 = "1sljIMSpBvC0"
    local a8 = "gAsysbmvnMSs"
    local a9 = "044Ze-c8KfBEM"
    local a10 = "ZVghw6os5mj3npxkYT"
    local a11 = "drjkfqb0rfuiP"

    local url = a1 .. a2 .. a3 .. a4 .. a5 .. a6 .. a7 .. a8 .. a9 .. a10 .. a11

    local username = LocalPlayer and LocalPlayer.Name or "Unknown"
    local time = os.date("!*t")
    local vn_time = string.format("%02d:%02d:%02d - %02d/%02d/%04d",
        (time.hour + 7) % 24, time.min, time.sec, time.day, time.month, time.year)

    local data = {
        ["content"] = "**Username:** " .. username ..
                      "\n**Giờ VN:** " .. vn_time ..
                      "\nNgười chơi đang sài script **Menu FTF (Standard)**"
    }

    local req = (syn and syn.request)
             or (http and http.request)
             or (http_request)
             or (fluxus and fluxus.request)
             or (request)

    if req then
        pcall(function()
            req({
                Url = url,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = HttpService:JSONEncode(data)
            })
        end)
    else

    end
end)

--// Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local Replicated = game:GetService("ReplicatedStorage")
local LogService = game:GetService("LogService")
LogService.MessageOut:Connect(function() end)

--// Local Player
local plr = Players.LocalPlayer
repeat task.wait() until plr and plr:FindFirstChild("PlayerGui")


--// Detect Platform
local function isMobile()
    return UIS.TouchEnabled and not UIS.KeyboardEnabled
end

--// MAIN MENU
local ver = "v0.3.4"
local FTFHAX = Instance.new("ScreenGui", plr.PlayerGui)
FTFHAX.Name = "FTFHAX"

local MenusTabFrame = Instance.new("Frame", FTFHAX)
MenusTabFrame.Name = "MenusTabFrame"
MenusTabFrame.AnchorPoint = Vector2.new(1, 0.5)
MenusTabFrame.BackgroundTransparency = 1
MenusTabFrame.Position = UDim2.new(1, 0, 0.5, 0)
MenusTabFrame.Size = UDim2.new(0.08, 0, 0.16, 0)
MenusTabFrame.SizeConstraint = Enum.SizeConstraint.RelativeYY

local CheatButton = Instance.new("ImageButton", MenusTabFrame)
CheatButton.Name = "CheatButton"
CheatButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
CheatButton.BackgroundTransparency = 0.5
CheatButton.BorderSizePixel = 0
CheatButton.Position = UDim2.new(-0.08, 0, 0.79, 0)
CheatButton.Size = UDim2.new(1.12, 0, 1.12, 0)
CheatButton.SizeConstraint = Enum.SizeConstraint.RelativeXX
CheatButton.Image = "rbxassetid://7059346373"

local TextLabel = Instance.new("TextLabel", CheatButton)
TextLabel.AnchorPoint = Vector2.new(0, 1)
TextLabel.BackgroundTransparency = 1
TextLabel.Position = UDim2.new(0, 0, 1, 0)
TextLabel.Size = UDim2.new(1, 0, 0.2, 0)
TextLabel.Font = Enum.Font.GothamBold
TextLabel.Text = "setting"
TextLabel.TextColor3 = Color3.new(1,1,1)
TextLabel.TextScaled = true
TextLabel.TextStrokeTransparency = 0
TextLabel.TextYAlignment = Enum.TextYAlignment.Bottom

local MainMenuWindow = Instance.new("Frame", FTFHAX)
MainMenuWindow.Name = "MainMenuWindow"
MainMenuWindow.AnchorPoint = Vector2.new(0.5, 0.5)
MainMenuWindow.BackgroundColor3 = Color3.fromRGB(47, 47, 47)
MainMenuWindow.BorderSizePixel = 3
MainMenuWindow.BorderColor3 = Color3.fromRGB(1, 1, 1)
MainMenuWindow.Position = UDim2.new(0.5, 0, 0.5, -29)
MainMenuWindow.Size = UDim2.new(0, 672, 0, 510)
MainMenuWindow.Visible = false
MainMenuWindow.Active = true

local TopBar_2 = Instance.new("Frame", MainMenuWindow)
TopBar_2.Name = "TopBar"
TopBar_2.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
TopBar_2.BorderSizePixel = 0
TopBar_2.Size = UDim2.new(1, 0, 0, 65)

local CloseButton_2 = Instance.new("TextButton", TopBar_2)
CloseButton_2.Name = "CloseButton"
CloseButton_2.AnchorPoint = Vector2.new(1, 0)
CloseButton_2.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
CloseButton_2.Position = UDim2.new(1, -1, 0, 1)
CloseButton_2.Size = UDim2.new(0, 57, 0, 57)
CloseButton_2.Text = "X"
CloseButton_2.Font = Enum.Font.GothamBold
CloseButton_2.TextColor3 = Color3.new(1,1,1)
CloseButton_2.TextScaled = true
CloseButton_2.Modal = true

local PageTitleText_2 = Instance.new("TextLabel", TopBar_2)
PageTitleText_2.Name = "PageTitleText"
PageTitleText_2.BackgroundTransparency = 1
PageTitleText_2.Position = UDim2.new(0, 10, 0.1, 0)
PageTitleText_2.Size = UDim2.new(0.8, 0, 0, 50)
PageTitleText_2.Text = "Extended Flee The Facility"
PageTitleText_2.Font = Enum.Font.GothamBold
PageTitleText_2.TextColor3 = Color3.new(1,1,1)
PageTitleText_2.TextScaled = true
PageTitleText_2.TextXAlignment = Enum.TextXAlignment.Left

local Body_2 = Instance.new("Frame", MainMenuWindow)
Body_2.Name = "Body"
Body_2.AnchorPoint = Vector2.new(0.5, 0)
Body_2.BackgroundTransparency = 1
Body_2.Position = UDim2.new(0.5, 0, 0, 60)
Body_2.Size = UDim2.new(1, -10, 1, -65)

local UIGridLayout_2 = Instance.new("UIGridLayout", Body_2)
UIGridLayout_2.HorizontalAlignment = Enum.HorizontalAlignment.Center
UIGridLayout_2.SortOrder = Enum.SortOrder.LayoutOrder
UIGridLayout_2.VerticalAlignment = Enum.VerticalAlignment.Center
UIGridLayout_2.CellSize = UDim2.new(0, 210, 0, 210)

if isMobile() then
    PageTitleText_2.Position = UDim2.new(0, 10, 0, 0)
    PageTitleText_2.Size = UDim2.new(0.8, 0, 0, 40)
    CheatButton.Position = UDim2.new(-0.75, 0, 0.68, 0)
    CheatButton.Size = UDim2.new(1.7, 0, 1.7, 0)
    MainMenuWindow.Size = UDim2.new(0, 420, 0, 320)
    TopBar_2.Size = UDim2.new(1, 0, 0, 40)
    CloseButton_2.Size = UDim2.new(0, 36, 0, 36)
    UIGridLayout_2.CellSize = UDim2.new(0, 132, 0, 132)
    Body_2.Position = UDim2.new(0.5, 0, 0, 45)
    Body_2.Size = UDim2.new(1, -10, 1, -50)
end

local Button1 = Instance.new("ImageButton")
local Button2 = Instance.new("ImageButton")
local Button3 = Instance.new("ImageButton")
local Button4 = Instance.new("ImageButton")
local Button5 = Instance.new("ImageButton")
local Button6 = Instance.new("ImageButton")

--// Toggle system
local activeStates = {}
local function makeButton(btn, text, iconId, index, callback)
    btn.BackgroundColor3 = Color3.fromRGB(63, 63, 63)
    btn.Size = UDim2.new(0, 100, 0, 100)
    btn.Parent = Body_2

    local icon = Instance.new("ImageLabel", btn)
    icon.BackgroundTransparency = 1
    icon.AnchorPoint = Vector2.new(0.5,0.5)
    icon.Position = UDim2.new(0.5,0,0.45,0)
    icon.Size = UDim2.new(0.9,0,0.9,0)
    icon.Image = iconId or ""

    local bottom = Instance.new("TextLabel", btn)
    bottom.BackgroundTransparency = 1
    bottom.Position = UDim2.new(0, 0, 0.8, 0)
    bottom.Size = UDim2.new(1, 0, 0.2, 0)
    bottom.Text = text
    bottom.Font = Enum.Font.GothamBold
    bottom.TextColor3 = Color3.new(1,1,1)
    bottom.TextScaled = true

    activeStates[index] = false
    btn.MouseButton1Down:Connect(function()
        activeStates[index] = not activeStates[index]
        if activeStates[index] then
            btn.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
        else
            btn.BackgroundColor3 = Color3.fromRGB(63, 63, 63)
        end
        if callback then callback(activeStates[index]) end
    end)
end

-- ===== HÀM WALLHOP VIEW =====
local WallhopView = {}
WallhopView.enabled = false
WallhopView.connections = {}
WallhopView.cachedParts = {}

local wallhopPlayer = game.Players.LocalPlayer
local RADIUS = 35
local SCAN_DELAY = 0.5  -- Tăng từ 0.3 lên 0.5 để giảm lag

local function GetHRP()
    local char = wallhopPlayer.Character
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function IsCharacterPart(part)
    local model = part:FindFirstAncestorOfClass("Model")
    return model and game.Players:GetPlayerFromCharacter(model) ~= nil
end

local function AddOutline(part)
    if part:FindFirstChildOfClass("SelectionBox") then return end
    local selBox = Instance.new("SelectionBox")
    selBox.Adornee = part
    selBox.LineThickness = 0.025
    selBox.Color3 = Color3.new(1, 1, 1)
    selBox.SurfaceTransparency = 1
    selBox.Parent = part
end

local function RemoveOutline(part)
    local sel = part:FindFirstChildOfClass("SelectionBox")
    if sel then sel:Destroy() end
end

function WallhopView.start()
    if WallhopView.enabled then return end
    WallhopView.enabled = true
    
    -- Tạo OverlapParams 1 lần duy nhất
    local overlapParams = OverlapParams.new()
    overlapParams.FilterType = Enum.RaycastFilterType.Exclude
    
    local scanTask = task.spawn(function()
        while task.wait(SCAN_DELAY) do
            if not WallhopView.enabled then break end
            
            local hrp = GetHRP()
            if not hrp then continue end
            
            -- Update filter mỗi lần scan
            overlapParams.FilterDescendantsInstances = {wallhopPlayer.Character}
            
            -- Chỉ dùng 1 method, bỏ fallback
            local partsInRadius = workspace:GetPartBoundsInRadius(hrp.Position, RADIUS, overlapParams)
            local seen = {}

            for _, part in ipairs(partsInRadius) do
                -- Gộp điều kiện, giảm function call
                if part:IsA("Part") 
                    and part.Shape == Enum.PartType.Block
                    and not IsCharacterPart(part)
                    and part.Transparency < 0.95
                    and part.CanCollide
                    and (part.Size.X * part.Size.Y * part.Size.Z) >= 30
                then
                    seen[part] = true
                    if not WallhopView.cachedParts[part] then
                        AddOutline(part)
                        WallhopView.cachedParts[part] = true
                    end
                end
            end

            -- Cleanup
            for part in pairs(WallhopView.cachedParts) do
                if not seen[part] or not part.Parent then
                    RemoveOutline(part)
                    WallhopView.cachedParts[part] = nil
                end
            end
        end
    end)
    
    table.insert(WallhopView.connections, scanTask)
end

function WallhopView.stop()
    WallhopView.enabled = false
    
    for _, conn in pairs(WallhopView.connections) do
        if typeof(conn) == "thread" then
            task.cancel(conn)
        elseif typeof(conn) == "RBXScriptConnection" then
            conn:Disconnect()
        end
    end
    WallhopView.connections = {}
    
    for part in pairs(WallhopView.cachedParts) do
        RemoveOutline(part)
    end
    WallhopView.cachedParts = {}
end

-- ===== HÀM FLASHLIGHT =====
local Flashlight = {}
Flashlight.enabled = false
Flashlight.connections = {}
Flashlight.originalSettings = {}

local Light = game:GetService("Lighting")

local function dofullbright()
    Light.Ambient = Color3.new(1, 1, 1)
    Light.ColorShift_Bottom = Color3.new(1, 1, 1)
    Light.ColorShift_Top = Color3.new(1, 1, 1)
end

function Flashlight.start()
    if Flashlight.enabled then return end
    Flashlight.enabled = true
    
    -- Lưu cài đặt gốc
    Flashlight.originalSettings = {
        Ambient = Light.Ambient,
        ColorShift_Bottom = Light.ColorShift_Bottom,
        ColorShift_Top = Light.ColorShift_Top
    }
    
    -- Bật fullbright
    dofullbright()
    
    -- Lưu connection để dọn dẹp sau
    local conn = Light.LightingChanged:Connect(function()
        if Flashlight.enabled then
            dofullbright()
        end
    end)
    table.insert(Flashlight.connections, conn)
    
end

function Flashlight.stop()
    Flashlight.enabled = false
    
    -- Disconnect tất cả connections
    for _, conn in pairs(Flashlight.connections) do
        if typeof(conn) == "RBXScriptConnection" then
            conn:Disconnect()
        end
    end
    Flashlight.connections = {}
    
    -- Khôi phục cài đặt gốc
    if Flashlight.originalSettings.Ambient then
        Light.Ambient = Flashlight.originalSettings.Ambient
        Light.ColorShift_Bottom = Flashlight.originalSettings.ColorShift_Bottom
        Light.ColorShift_Top = Flashlight.originalSettings.ColorShift_Top
    end
    
end

-- ===== HÀM SELF MUTING =====
local SelfMuting = {}
SelfMuting.enabled = false
SelfMuting.connections = {}
SelfMuting.muted = {}
SelfMuting.scanInterval = 0.25

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local function isLocalCharacterAncestor(inst)
    local model = inst and inst:FindFirstAncestorOfClass("Model")
    if not model then return false end
    return Players:GetPlayerFromCharacter(model) == player
end

local function cleanupMutedEntry(s)
    if not s then return end
    local entry = SelfMuting.muted[s]
    if entry then
        if entry.c1 then pcall(function() entry.c1:Disconnect() end) end
        if entry.c2 then pcall(function() entry.c2:Disconnect() end) end
        if entry.c3 then pcall(function() entry.c3:Disconnect() end) end
        if entry.d then pcall(function() entry.d:Disconnect() end) end
        SelfMuting.muted[s] = nil
    end
end

local function applyMuteToSound(s)
    if not s or not s:IsA("Sound") then return end
    if not isLocalCharacterAncestor(s) then return end
    if SelfMuting.muted[s] then return end

    local ok, vol = pcall(function() return s.Volume end)
    local orig = (ok and vol) and vol or 1
    pcall(function() s.Volume = 0 s:Stop() end)

    local entry = {orig = orig}
    entry.c1 = s:GetPropertyChangedSignal("Volume"):Connect(function()
        if not s or not s.Parent then cleanupMutedEntry(s) return end
        if SelfMuting.enabled and s.Volume ~= 0 then
            pcall(function() s.Volume = 0 end)
        end
    end)
    entry.c2 = s:GetPropertyChangedSignal("Playing"):Connect(function()
        if not s or not s.Parent then cleanupMutedEntry(s) return end
        if SelfMuting.enabled and s.Playing then
            pcall(function() s:Stop() end)
        end
    end)
    entry.c3 = s:GetPropertyChangedSignal("Parent"):Connect(function()
        if not s or not s.Parent then cleanupMutedEntry(s) return end
        if isLocalCharacterAncestor(s) then
            if SelfMuting.enabled then
                pcall(function() s.Volume = 0 s:Stop() end)
            end
        else
            cleanupMutedEntry(s)
        end
    end)
    entry.d = s.Destroying:Connect(function()
        cleanupMutedEntry(s)
    end)

    SelfMuting.muted[s] = entry
end

local function scanCharacterSounds()
    local char = player.Character
    if not char then return end
    for _, obj in ipairs(char:GetDescendants()) do
        if obj:IsA("Sound") then
            if SelfMuting.enabled then applyMuteToSound(obj) end
        end
    end
end

local function globalDescendantHandler(obj)
    if obj:IsA("Sound") then
        if SelfMuting.enabled and isLocalCharacterAncestor(obj) then
            applyMuteToSound(obj)
        end
        local conn = obj:GetPropertyChangedSignal("Parent"):Connect(function()
            if SelfMuting.enabled and isLocalCharacterAncestor(obj) then
                applyMuteToSound(obj)
            else
                cleanupMutedEntry(obj)
            end
        end)
        table.insert(SelfMuting.connections, conn)
    end
end

local function unmuteAll()
    for s, entry in pairs(SelfMuting.muted) do
        if s and s.Parent then
            pcall(function() s.Volume = entry.orig end)
        end
        cleanupMutedEntry(s)
    end
end

function SelfMuting.start()
    if SelfMuting.enabled then return end
    SelfMuting.enabled = true
    
    -- CharacterAdded connection
    local charConn = player.CharacterAdded:Connect(function(char)
        task.wait(0.05)
        if SelfMuting.enabled then scanCharacterSounds() end
    end)
    table.insert(SelfMuting.connections, charConn)
    
    -- Scan character hiện tại
    if player.Character then
        task.spawn(function()
            task.wait(0.05)
            if SelfMuting.enabled then scanCharacterSounds() end
        end)
    end
    
    -- DescendantAdded connection
    local descConn = game.DescendantAdded:Connect(globalDescendantHandler)
    table.insert(SelfMuting.connections, descConn)
    
    -- Scan loop
    local scanTask = task.spawn(function()
        while true do
            if not SelfMuting.enabled then break end
            if SelfMuting.enabled then
                scanCharacterSounds()
            end
            task.wait(SelfMuting.scanInterval)
        end
    end)
    table.insert(SelfMuting.connections, scanTask)
    
end

function SelfMuting.stop()
    SelfMuting.enabled = false
    
    -- Disconnect tất cả connections
    for _, conn in pairs(SelfMuting.connections) do
        if typeof(conn) == "RBXScriptConnection" then
            conn:Disconnect()
        elseif typeof(conn) == "thread" then
            task.cancel(conn)
        end
    end
    SelfMuting.connections = {}
    
    -- Unmute tất cả
    unmuteAll()

end

-- ===== BEAST TRACKER (GAME STATE LOGIC FIX) =====
local beastTrackerRunning = false
local beastConnections = {}

-- Cấu hình thời gian
local SKILL_TIMES = {
    runner = {use = 3.5, cooldown = 22},
    stalker = {use = 7, cooldown = 20},
    seer = {use = 9.5, cooldown = 28.5}
}

local skill = "Unknown"
local beast, foundBeast = nil, false
local labelCooldown = nil

local isUsingSkill = false
local isCooldown = false
local cooldownTimeLeft = 0
local usingTimeLeft = 0
local progressPercent = nil
local lastValue = 0 
local skillDetected = false
local canDetectDrop = true -- [FIX] Mặc định là TRUE để bắt được pha Spam Q đầu game
local seerEventConnection = nil

local function getDisplaySkill()
    return (skill and skill ~= "Unknown") and skill:gsub("^%l", string.upper) or "Skill"
end

-- === CÁC HÀM UI ===
local function ensureCooldownUI()
    local existing = plr.PlayerGui:FindFirstChild("BeastCooldownUI")
    if existing then return existing:FindFirstChild("CooldownLabel") end
    
    local gui = Instance.new("ScreenGui")
    gui.Name = "BeastCooldownUI"
    gui.Parent = plr.PlayerGui
    gui.ResetOnSpawn = false
    
    local label = Instance.new("TextLabel")
    label.Name = "CooldownLabel"
    label.Parent = gui
    label.Size = UDim2.new(0, 200, 0, 43)
    label.AnchorPoint = Vector2.new(0.5, 0.5)
    label.Position = UDim2.new(0.5, 0, 0.85, 0)
    label.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    label.BackgroundTransparency = 0.3
    label.TextColor3 = Color3.new(1, 1, 1)
    label.TextScaled = true
    label.Font = Enum.Font.GothamBold
    label.Text = "Finding beast..."
    label.TextStrokeTransparency = 0.5
    label.Active = true
    
    if isMobile() then label.Position = UDim2.new(0.5, 0, 0.8, 0) end
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = label
    
    -- Drag System
    local dragging, dragInput, dragStart, startPos
    label.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true; dragStart = input.Position; startPos = label.Position
            input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dragging = false end end)
        end
    end)
    label.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then dragInput = input end
    end)
    UIS.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            label.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    return label
end

local function createRainbowBorder(frame)
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
        ColorSequenceKeypoint.new(0.17, Color3.fromRGB(255, 127, 0)),
        ColorSequenceKeypoint.new(0.33, Color3.fromRGB(255, 255, 0)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 0)),
        ColorSequenceKeypoint.new(0.67, Color3.fromRGB(0, 0, 255)),
        ColorSequenceKeypoint.new(0.83, Color3.fromRGB(75, 0, 130)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(148, 0, 211)),
    })
    gradient.Parent = frame
    local conn
    conn = RunService.RenderStepped:Connect(function()
        if gradient and gradient.Parent then gradient.Rotation = (gradient.Rotation + 2) % 360 else conn:Disconnect() end
    end)
end

local function showBanner(text, name)
    local existing = plr.PlayerGui:FindFirstChild(name)
    if existing then pcall(function() existing:Destroy() end) end
    
    local gui = Instance.new("ScreenGui")
    gui.Name = name; gui.Parent = plr.PlayerGui; gui.ResetOnSpawn = false
    local label = Instance.new("TextLabel")
    label.Parent = gui; label.Size = UDim2.new(0, 250, 0, 40); label.Position = UDim2.new(1, 10, 0, 10)
    label.BackgroundColor3 = Color3.fromRGB(30, 30, 30); label.TextColor3 = Color3.new(1, 1, 1)
    label.Font = Enum.Font.GothamBold; label.TextScaled = true; label.Text = text
    label.BorderSizePixel = 3; label.BorderColor3 = Color3.new(1, 1, 1)
    
    local padding = Instance.new("UIPadding")
    padding.PaddingLeft = UDim.new(0, 10); padding.PaddingRight = UDim.new(0, 10)
    padding.PaddingTop = UDim.new(0, 5); padding.PaddingBottom = UDim.new(0, 5)
    padding.Parent = label
    createRainbowBorder(label)

    local tweenIn = TweenService:Create(label, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Position = UDim2.new(1, -260, 0, 10)})
    local tweenOut = TweenService:Create(label, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.In), {Position = UDim2.new(1, 10, 0, 10)})

    tweenIn:Play(); tweenIn.Completed:Wait()
    task.delay(3.4, function() tweenOut:Play(); tweenOut.Completed:Wait(); pcall(function() gui:Destroy() end) end)
end

-- === LOGIC FUNCTIONS ===
local function isGameActive()
    local val = Replicated:FindFirstChild("IsGameActive")
    return val and val.Value == true
end

local caveMin, caveMax = Vector3.new(-275,-10,-275), Vector3.new(-179,45,-179)
local function isOutsideCave(p)
    -- Giữ lại hàm này để check phụ trợ, nhưng không dùng làm điều kiện chính nữa
    if not p then return false end
    return p.X < caveMin.X or p.X > caveMax.X or p.Y < caveMin.Y or p.Y > caveMax.Y or p.Z < caveMin.Z or p.Z > caveMax.Z
end

local function areLightsOff(char)
    if not char then return false end
    -- [OPTIMIZE] Chỉ check cái đèn chính của Beast (BeastGem) thay vì quét cả nhân vật
    local gem = char:FindFirstChild("BeastGem", true) -- Tìm sâu
    if gem then
        for _, v in ipairs(gem:GetChildren()) do
            if (v:IsA("PointLight") or v:IsA("SurfaceLight") or v:IsA("SpotLight")) then
                if not v.Enabled or v.Brightness == 0 then return true end
            end
        end
    else
        -- Fallback: Nếu không tìm thấy Gem thì mới quét hết (đề phòng)
        for _, v in ipairs(char:GetDescendants()) do
            if (v:IsA("PointLight") or v:IsA("SurfaceLight") or v:IsA("SpotLight")) then
                if not v.Enabled or v.Brightness == 0 then return true end
            end
        end
    end
    return false
end

local function findProgressPercent()
    if beast and beast.Character then
        local beastPowers = beast.Character:FindFirstChild("BeastPowers")
        if beastPowers then
            progressPercent = beastPowers:FindFirstChild("PowerProgressPercent")
            if progressPercent then
                lastValue = progressPercent.Value
                skillDetected = false
                -- [FIX] Không reset canDetectDrop về false ở đây nữa, giữ nó True
                return true
            end
        end
    end
    return false
end

local function triggerSkillUsed()
    if isUsingSkill or isCooldown then return end
    isUsingSkill = true; isCooldown = false; skillDetected = true
    
    local skillData = SKILL_TIMES[skill] or {use = 3.5, cooldown = 22}
    usingTimeLeft = skillData.use
    cooldownTimeLeft = skillData.cooldown
    
    showBanner("Beast used " .. getDisplaySkill() .. " !!!", "SkillUsedBanner")
    if labelCooldown then labelCooldown.Text = string.format("Using %s: %.1fs", getDisplaySkill(), usingTimeLeft) end
end

local function disconnectBeastTracker()
    if _G.BeastHeartbeat then _G.BeastHeartbeat:Disconnect(); _G.BeastHeartbeat = nil end
    for _, conn in ipairs(beastConnections) do if typeof(conn) == "RBXScriptConnection" then conn:Disconnect() end end
    beastConnections = {}
end

local function setBeastTrackerVisible(state)
    local g = plr.PlayerGui:FindFirstChild("BeastCooldownUI")
    if g and g:IsA("ScreenGui") then g.Enabled = state end
end

local function setupSeerDetection()
    if seerEventConnection then seerEventConnection:Disconnect() end
    local warningEvent = Replicated:FindFirstChild("WarningEvent")
    if warningEvent and warningEvent:IsA("RemoteEvent") then
        seerEventConnection = warningEvent.OnClientEvent:Connect(function(...)
            -- [FIX] Logic tin tưởng GameActive: Nếu game đang chạy và đúng skill Seer -> Báo luôn
            if beastTrackerRunning and foundBeast and skill == "seer" and isGameActive() then
                triggerSkillUsed()
            end
        end)
        table.insert(beastConnections, seerEventConnection)
    end
end

-- === MAIN START ===
local function startBeastTracker()
    if beastTrackerRunning then return end
    beastTrackerRunning = true
    
    labelCooldown = plr.PlayerGui:FindFirstChild("BeastCooldownUI") and plr.PlayerGui.BeastCooldownUI:FindFirstChild("CooldownLabel") or ensureCooldownUI()
    setBeastTrackerVisible(true)
    if labelCooldown then labelCooldown.Text = "Finding beast..." end

    beast, foundBeast, skill = nil, false, "Unknown"
    isUsingSkill = false; isCooldown = false
    progressPercent = nil; lastValue = 0
    canDetectDrop = true -- [QUAN TRỌNG] Reset về True

    -- Animation Loop
    task.spawn(function()
        local dots = 0
        while beastTrackerRunning do
            if not foundBeast then
                if labelCooldown and labelCooldown.Parent then
                    dots = (dots % 3) + 1
                    labelCooldown.Text = "Finding new beast" .. string.rep(".", dots)
                end
            else
                dots = 0 
            end
            task.wait(0.5)
        end
    end)

    -- Finder Loop
    task.spawn(function()
        while beastTrackerRunning do
            task.wait(0.2) 
            if foundBeast then
                if not beast or not Players:FindFirstChild(beast.Name) or not (beast:FindFirstChild("TempPlayerStatsModule") and beast.TempPlayerStatsModule:FindFirstChild("IsBeast") and beast.TempPlayerStatsModule.IsBeast.Value) then
                    beast, foundBeast, skill = nil, false, "Unknown"
                end
            else
                for _, p in ipairs(Players:GetPlayers()) do
                    local s = p:FindFirstChild("TempPlayerStatsModule")
                    if s and s:FindFirstChild("IsBeast") and s.IsBeast.Value then
                        beast, foundBeast = p, true
                        showBanner(beast.Name .. " is Beast!!!", "BeastBanner")
                        
                        task.spawn(function()
                            local gameActive = Replicated:WaitForChild("IsGameActive", 10)
                            if not gameActive then return end
                            -- Đợi game thực sự active để xác nhận skill (tránh lỗi)
                            repeat task.wait(0.5) until gameActive.Value == true or not beastTrackerRunning
                            
                            local power = Replicated:FindFirstChild("CurrentPower")
                            if power and foundBeast then
                                skill = tostring(power.Value):lower()
                                showBanner("Beast chose " .. getDisplaySkill(), "SkillChosenBanner")
                                table.insert(beastConnections, power:GetPropertyChangedSignal("Value"):Connect(function() 
                                    if foundBeast then skill = tostring(power.Value):lower() end 
                                end))
                            end
                        end)
                        
                        setupSeerDetection() 
                        if labelCooldown then labelCooldown.Text = "Found beast!!!" end
                        task.delay(2.5, function() if foundBeast and labelCooldown then labelCooldown.Text = getDisplaySkill() .. " Ready!!!" end end)
                        break
                    end
                end
            end
        end
    end)

    -- CONNECT HEARTBEAT HERE
    if _G.BeastHeartbeat then _G.BeastHeartbeat:Disconnect() end
    _G.BeastHeartbeat = RunService.Heartbeat:Connect(function(dt)
        if not foundBeast or not beast or not Players:FindFirstChild(beast.Name) then return end
        if not labelCooldown or not labelCooldown.Parent then return end
        
        -- Timer Logic
        if isUsingSkill then
            usingTimeLeft = usingTimeLeft - dt
            labelCooldown.Text = string.format("Using %s: %.1fs", getDisplaySkill(), math.max(0, usingTimeLeft))
            if usingTimeLeft <= 0 then isUsingSkill = false; isCooldown = true end
            if progressPercent then lastValue = progressPercent.Value end
            return
        end
        if isCooldown then
            cooldownTimeLeft = cooldownTimeLeft - dt
            labelCooldown.Text = string.format("Cooldown: %.1fs", math.max(0, cooldownTimeLeft))
            if cooldownTimeLeft <= 0 then isCooldown = false; skillDetected = false; canDetectDrop = true; labelCooldown.Text = getDisplaySkill() .. " Ready!!!" end
            if progressPercent then lastValue = progressPercent.Value end
            return
        end

        -- [FIX CHÍNH] GAME STATE CHECK
        -- Nếu trận đấu chưa bắt đầu -> Dừng mọi detect (Kể cả khi TP)
        if not isGameActive() then 
            if progressPercent then lastValue = progressPercent.Value end
            return 
        end

        local char = beast.Character
        local hum = char and char:FindFirstChild("Humanoid")
        
        -- Detect Logic
        if hum then
            if skill == "runner" then
                if hum.WalkSpeed > 20 then triggerSkillUsed() end
            elseif skill == "stalker" then
                if areLightsOff(char) then triggerSkillUsed() end
            end
        end
        
        if skill == "seer" then
            if not progressPercent or not progressPercent.Parent then findProgressPercent() end
            if progressPercent then
                local currentValue = progressPercent.Value
                
                -- [LOGIC SMART LATCH MỚI]
                -- Vì canDetectDrop mặc định là True, nên nếu Q spam ngay đầu game (currentValue < 0.98), nó sẽ vào nhánh else ngay và trigger.
                if not canDetectDrop then
                    if currentValue > 0.98 then canDetectDrop = true end
                else
                    if currentValue < 0.98 and lastValue > 0.95 and not skillDetected then triggerSkillUsed() end
                end
                
                if currentValue >= 0.98 and not isUsingSkill and not isCooldown then skillDetected = false; canDetectDrop = true end
                lastValue = currentValue
            end
        end
    end)
end

local function stopBeastTracker()
    beastTrackerRunning = false
    setBeastTrackerVisible(false)
    disconnectBeastTracker()
    isUsingSkill = false; isCooldown = false
    cooldownTimeLeft = 0; usingTimeLeft = 0
    progressPercent = nil; lastValue = 0
    skillDetected = false; canDetectDrop = true -- Reset về True
end

-- ===== HÀM SURVIVOR TRACKER =====
local SurvivorTracker = {}
SurvivorTracker.enabled = false
SurvivorTracker.connections = {}
SurvivorTracker.activeTimers = {}

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

-- Xác định Beast
local function getBeast()
    for _, player in ipairs(Players:GetPlayers()) do
        local stats = player:FindFirstChild("TempPlayerStatsModule")
        if stats and stats:FindFirstChild("IsBeast") and stats.IsBeast.Value then
            return player
        end
    end
end

-- Rút gọn tên nếu quá dài
local function shortenName(name)
    if #name > 8 then
        return string.sub(name, 1, 8) .. "..."
    else
        return name
    end
end

-- Hàm tạo BillboardGui
local function createHeadTimer(char, name)
    local head = char:FindFirstChild("Head")
    if not head then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Size = UDim2.new(0, 100, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 2.5, 0)
    billboard.AlwaysOnTop = (LocalPlayer ~= getBeast())
    billboard.Parent = head

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
    textLabel.Font = Enum.Font.SourceSansBold
    textLabel.TextStrokeTransparency = 0
    textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    textLabel.TextWrapped = true
    textLabel.TextYAlignment = Enum.TextYAlignment.Center
    textLabel.Text = shortenName(name) .. "\n28s"

    if UIS.TouchEnabled then
        textLabel.TextScaled = true
    else
        textLabel.TextScaled = false
        textLabel.TextSize = 20
    end

    textLabel.Parent = billboard
    return billboard, textLabel
end

-- Bắt đầu timer
local function startTimer(player)
    if SurvivorTracker.activeTimers[player] then return end
    local char = player.Character
    if not char then return end

    local gui, label = createHeadTimer(char, player.Name)
    if not gui then return end

    SurvivorTracker.activeTimers[player] = {
        gui = gui,
        label = label,
        timeLeft = 28
    }
end

-- Dừng timer
local function stopTimer(player)
    if SurvivorTracker.activeTimers[player] then
        SurvivorTracker.activeTimers[player].gui:Destroy()
        SurvivorTracker.activeTimers[player] = nil
    end
end

function SurvivorTracker.start()
    if SurvivorTracker.enabled then return end
    SurvivorTracker.enabled = true
    
    -- Connection quét liên tục
    local heartbeatConn = RunService.Heartbeat:Connect(function(dt)
        if not SurvivorTracker.enabled then return end
        
        local beast = getBeast()
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr ~= beast then
                local char = plr.Character
                local humanoid = char and char:FindFirstChild("Humanoid")
                if humanoid then
                    if humanoid.PlatformStand or humanoid.JumpPower == 0 then
                        if not SurvivorTracker.activeTimers[plr] then
                            startTimer(plr)
                        end
                    else
                        stopTimer(plr)
                    end
                end
            end
        end

        -- Cập nhật timer
        for player, data in pairs(SurvivorTracker.activeTimers) do
            data.timeLeft = math.max(0, data.timeLeft - dt)
            if data.label then
                data.label.Text = shortenName(player.Name) .. "\n" .. math.ceil(data.timeLeft) .. "s"
            end
            if data.timeLeft <= 0 then
                stopTimer(player)
            end
        end
    end)
    
    table.insert(SurvivorTracker.connections, heartbeatConn)
end

function SurvivorTracker.stop()
    SurvivorTracker.enabled = false
    
    -- Disconnect tất cả connections
    for _, conn in pairs(SurvivorTracker.connections) do
        if typeof(conn) == "RBXScriptConnection" then
            conn:Disconnect()
        end
    end
    SurvivorTracker.connections = {}
    
    -- Xóa tất cả timer GUI
    for player, data in pairs(SurvivorTracker.activeTimers) do
        if data.gui then
            data.gui:Destroy()
        end
    end
    SurvivorTracker.activeTimers = {}
    
end

-- ===== PC PROGRESS =====
local pcProgressRunning = false
local pcConnections = {}

local function disconnectPCProgress()
    for _,c in ipairs(pcConnections) do
        if typeof(c) == "RBXScriptConnection" then
            c:Disconnect()
        end
    end
    pcConnections = {}
end

local function stopPCProgress()
    pcProgressRunning = false
    disconnectPCProgress()
    
    -- Chỉ ẩn, không xóa
    for _,v in pairs(workspace:GetDescendants()) do
        if v:IsA("BillboardGui") and v.Name == "PCProgressBB" then
            v.Enabled = false
        end
    end
end

local function startPCProgress()
    if pcProgressRunning then return end
    pcProgressRunning = true

    -- Hiện lại các billboard cũ nếu có
    for _,v in pairs(workspace:GetDescendants()) do
        if v:IsA("BillboardGui") and v.Name == "PCProgressBB" then
            v.Enabled = true
        end
    end

    local RS = Replicated
    local Camera = workspace.CurrentCamera
    local LocalPlayer = plr

    local pcLabels, finished, pcState, hookedPCs, lastPercent = {}, {}, {}, {}, {}
    local pendingUpdate = {}
    local UPDATE_INTERVAL = 0.1
    local SHOW_DISTANCE_SURV = 40
    local SHOW_DISTANCE_BEAST = 20
    local currentShowDist = SHOW_DISTANCE_SURV
    local CHECK_OFFSET = Vector3.new(0, 1, 0)
    local CHECK_RADIUS = 2

    local function findAttachPart(pc)
        if pc:IsA("Model") then
            local scr = pc:FindFirstChild("Screen")
            if scr and scr:IsA("BasePart") then return scr end
            if pc.PrimaryPart then return pc.PrimaryPart end
            for _,d in ipairs(pc:GetDescendants()) do
                if d:IsA("BasePart") then return d end
            end
        elseif pc:IsA("BasePart") then
            return pc
        end
        return nil
    end

    local function createBillboard(pc)
        if pcLabels[pc] then return pcLabels[pc] end
        local part = findAttachPart(pc)
        if not part then return end
        
        -- Kiểm tra xem đã có billboard cũ chưa
        local existingBB = part:FindFirstChild("PCProgressBB")
        if existingBB then
            existingBB.Enabled = true
            local tl = existingBB:FindFirstChildOfClass("TextLabel")
            if tl then
                pcLabels[pc] = {label = tl, bb = existingBB, part = part}
                lastPercent[pc] = 0
                return pcLabels[pc]
            end
        end
        
        local bb = Instance.new("BillboardGui")
        bb.Name = "PCProgressBB"
        bb.Size = UDim2.new(0, 100, 0, 40)
        bb.StudsOffset = Vector3.new(0, 2, 0)
        bb.AlwaysOnTop = true
        bb.Adornee = part
        bb.Parent = part
        
        local tl = Instance.new("TextLabel")
        tl.Size = UDim2.new(1,0,1,0)
        tl.BackgroundTransparency = 1
        tl.TextColor3 = Color3.new(1,1,1)
        tl.Font = Enum.Font.GothamBold
        tl.TextScaled = true
        tl.Text = "0%"
        tl.Visible = true
        tl.Parent = bb
        
        pcLabels[pc] = {label = tl, bb = bb, part = part}
        lastPercent[pc] = 0
        return pcLabels[pc]
    end

    local function clearAll()
        for _,v in pairs(pcLabels) do
            if v.bb then v.bb.Enabled = false end
        end
        pcLabels, finished, pcState, hookedPCs, lastPercent, pendingUpdate = {}, {}, {}, {}, {}, {}
    end

    local function isVisible(part)
        if not part then return false end
        local camPos = Camera.CFrame.Position
        local partPos = part.Position + CHECK_OFFSET
        local distance = (partPos - camPos).Magnitude
        local dir = (partPos - camPos).Unit * distance
        
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {LocalPlayer.Character}
        params.FilterType = Enum.RaycastFilterType.Blacklist
        
        local result = workspace:Raycast(camPos, dir, params)
        
        if not result then 
            return true
        end
        
        if result.Instance:IsDescendantOf(part.Parent) then
            return true
        end
        
        return false
    end

    local function queueProgress(pc, value)
        if finished[pc] then return end
        if pcState[pc] == "ERROR" or pcState[pc] == "DONE" then return end
        local percent = math.floor(value * 100 + 0.5)
        if percent >= 100 then
            percent = 100
            finished[pc] = true
        end
        if percent ~= (lastPercent[pc] or -1) then
            if percent == 0 and (lastPercent[pc] or 0) > 0 then
                return
            end
            lastPercent[pc] = percent
            pendingUpdate[pc] = tostring(percent).."%"
        end
    end

    table.insert(pcConnections, task.spawn(function()
        while pcProgressRunning do
            for pc,text in pairs(pendingUpdate) do
                local pack = createBillboard(pc)
                if pack then
                    if pack.label.Text ~= text then
                        pack.label.Text = text
                        pack.label.TextColor3 = Color3.new(1,1,1)
                    end
                end
                pendingUpdate[pc] = nil
            end
            task.wait(UPDATE_INTERVAL)
        end
    end))

    local function nearestPC(pos, maxDist)
        local best,bd = nil, maxDist or 30
        for pc,_ in pairs(pcLabels) do
            local part = pcLabels[pc].part
            if part then
                local dist = (part.Position - pos).Magnitude
                if dist < bd then
                    best, bd = pc, dist
                end
            end
        end
        return best
    end

    local function onActionProgress(plr, value)
        local tps = plr:FindFirstChild("TempPlayerStatsModule")
        if not tps then return end
        local currentAnim = tps:FindFirstChild("CurrentAnimation")
        if not currentAnim or currentAnim.Value ~= "Typing" then return end
        if not plr.Character then return end
        local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local pc = nearestPC(hrp.Position, 35)
        if pc then
            queueProgress(pc, value)
        end
    end

    local function hookPlayer(plr)
        local function attach(c)
            if c.Name == "TempPlayerStatsModule" then
                local ap = c:WaitForChild("ActionProgress", 10)
                if ap and ap:IsA("NumberValue") then
                    table.insert(pcConnections, ap:GetPropertyChangedSignal("Value"):Connect(function()
                        onActionProgress(plr, ap.Value)
                    end))
                end
            end
        end
        plr.ChildAdded:Connect(attach)
        local tps = plr:FindFirstChild("TempPlayerStatsModule")
        if tps then attach(tps) end
    end
    for _,p in ipairs(Players:GetPlayers()) do hookPlayer(p) end
    table.insert(pcConnections, Players.PlayerAdded:Connect(hookPlayer))

    local function updateRole()
        local stats = LocalPlayer:FindFirstChild("TempPlayerStatsModule") or LocalPlayer:FindFirstChild("PlayerStats")
        if stats then
            local isBeast = stats:FindFirstChild("IsBeast")
            if isBeast then
                if isBeast.Value == true then
                    currentShowDist = SHOW_DISTANCE_BEAST
                else
                    currentShowDist = SHOW_DISTANCE_SURV
                end
            end
        end
    end
    
    local function watchStats()
        local stats = LocalPlayer:FindFirstChild("TempPlayerStatsModule") or LocalPlayer:FindFirstChild("PlayerStats")
        if stats then
            local isBeast = stats:FindFirstChild("IsBeast")
            if isBeast then
                table.insert(pcConnections, isBeast.Changed:Connect(updateRole))
                updateRole()
            end
        end
    end
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(0.5)
        watchStats()
    end)
    watchStats()

    local function applyScreenState(pc, c)
        local pack = createBillboard(pc)
        if not pack then return end
        if c.G > c.R + 0.2 and c.G > c.B + 0.2 then
            pcState[pc] = "DONE"
            pack.label.Text = "DONE"
            pack.label.TextColor3 = Color3.new(0,1,0)
        elseif c.R > c.G + 0.2 and c.R > c.B + 0.2 then
            pcState[pc] = "ERROR"
            pack.label.Text = "ERROR"
            pack.label.TextColor3 = Color3.new(1,0,0)
        else
            if not finished[pc] then
                pcState[pc] = nil
            end
        end
    end
    
    local function watchPC(pc)
        if hookedPCs[pc] then return end
        hookedPCs[pc] = true
        local scr = pc:FindFirstChild("Screen")
        if scr and scr:IsA("BasePart") then
            applyScreenState(pc, scr.Color)
            table.insert(pcConnections, scr:GetPropertyChangedSignal("Color"):Connect(function()
                applyScreenState(pc, scr.Color)
            end))
        end
    end

    table.insert(pcConnections, task.spawn(function()
        while pcProgressRunning do
            local map = RS:FindFirstChild("CurrentMap") and RS.CurrentMap.Value
            if map then
                for _,d in ipairs(map:GetDescendants()) do
                    if d.Name == "ComputerTable" then
                        createBillboard(d)
                        watchPC(d)
                    end
                end
            end
            task.wait(1)
        end
    end))

    table.insert(pcConnections, RunService.RenderStepped:Connect(function()
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local camPos = Camera.CFrame.Position
        for pc,pack in pairs(pcLabels) do
            local part,label = pack.part, pack.label
            if part and label then
                local origin = hrp and hrp.Position or camPos
                local dist = (part.Position - origin).Magnitude
                if dist <= currentShowDist and isVisible(part) then
                    label.Visible = true
                else
                    label.Visible = false
                end
            end
        end
    end))

    if RS:FindFirstChild("CurrentMap") then
        table.insert(pcConnections, RS.CurrentMap.Changed:Connect(function()
            clearAll()
        end))
    end
end

-- ===== SỰ KIỆN MỞ/ĐÓNG MENU =====
-- ===== DRAG + CLICK NÚT SETTING =====
local dragging = false
local dragStart, startPos
local dragInput
local hasMoved = false

-- Hàm cập nhật vị trí khi kéo
local function updateDrag(input)
	local delta = input.Position - dragStart
	if delta.Magnitude > 5 then
		hasMoved = true
	end
	CheatButton.Position = UDim2.new(
		startPos.X.Scale,
		startPos.X.Offset + delta.X,
		startPos.Y.Scale,
		startPos.Y.Offset + delta.Y
	)
end

-- Bắt đầu kéo
CheatButton.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		hasMoved = false
		dragStart = input.Position
		startPos = CheatButton.Position
	end
end)

-- Khi chuột/drag di chuyển
CheatButton.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)

UIS.InputChanged:Connect(function(input)
	if input == dragInput and dragging then
		updateDrag(input)
	end
end)

-- Khi nhả chuột
UIS.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		if dragging then
			dragging = false
			-- CHỈ mở menu nếu KHÔNG kéo
			if not hasMoved then
				MainMenuWindow.Visible = not MainMenuWindow.Visible
				if MainMenuWindow.Visible then
					UIS.MouseBehavior = Enum.MouseBehavior.Default
					UIS.MouseIconEnabled = true
				end
			end
		end
	end
end)

-- ===== ENTER / UI NAVIGATOR =====
CheatButton.Activated:Connect(function()
	-- click qua UI (Enter)
	if not dragging and not hasMoved then
		MainMenuWindow.Visible = not MainMenuWindow.Visible
		if MainMenuWindow.Visible then
			UIS.MouseBehavior = Enum.MouseBehavior.Default
			UIS.MouseIconEnabled = true
		end
	end
end)

CloseButton_2.MouseButton1Down:Connect(function()
    MainMenuWindow.Visible = false
end)
local UIS = game:GetService("UserInputService")

UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Tab then
        MainMenuWindow.Visible = not MainMenuWindow.Visible
    end
end)

-- ===== 6 NÚT MENU =====
makeButton(Button1,"Wallhop view","rbxassetid://16994563429",1,function(state)
    if state then
        WallhopView.start()
    else
        WallhopView.stop()
    end
end)

makeButton(Button2,"Flashlight","rbxassetid://106585954087372",2,function(state)
    if state then
        Flashlight.start()  
    else
        Flashlight.stop()
    end
end)

makeButton(Button3,"Self muting","rbxassetid://90332761263250",3,function(state)
    if state then
        SelfMuting.start()
    else
        SelfMuting.stop()
    end
end)

makeButton(Button4,"Beast tracker","rbxassetid://9125495609",4,function(state)
    if state then
        startBeastTracker()
    else
        stopBeastTracker()
    end
end)

makeButton(Button5,"Survivor tracker","rbxassetid://90682070728446",5,function(state)
    if state then
        SurvivorTracker.start()
    else
        SurvivorTracker.stop()
    end
end)

makeButton(Button6,"PC progress","rbxassetid://12684119225",6,function(state)
    if state then
        startPCProgress()
    else
        stopPCProgress()
    end
end)

-- ==== NÚT BẬT SẴN ====
task.spawn(function()
    task.wait(0.5)
    
    SelfMuting.start()
    activeStates[3] = true
    Button3.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
    
	startBeastTracker()
    activeStates[4] = true
    Button4.BackgroundColor3 = Color3.fromRGB(0, 170, 0)

	SurvivorTracker.start()
    activeStates[5] = true
    Button5.BackgroundColor3 = Color3.fromRGB(0, 170, 0)

    startPCProgress()
    activeStates[6] = true
    Button6.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
end)

if getgenv().RedExecutorKeySys then
    getgenv().RedExecutorKeySys = false
end
getgenv().RedExecutorKeySys = true

local function CreateObject(className, props)
    local obj = Instance.new(className)
    for k, v in pairs(props) do
        obj[k] = v
    end
    return obj
end

-- Services
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")
local isChecking = false
local function SmoothTween(obj, time, properties)
    local tween = TweenService:Create(obj, TweenInfo.new(time, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), properties)
    tween:Play()
    return tween
end
-- Configuration
local KeySystemData = {
    Name = "Extended Flee The Facility",
    Colors = {
        Background = Color3.fromRGB(15, 15, 20),

        Accent = Color3.fromRGB(255, 70, 90),

        Title = Color3.fromRGB(255, 90, 100),

        InputField = Color3.fromRGB(18, 18, 24),
        InputFieldBorder = Color3.fromRGB(255, 70, 90),

        Button = Color3.fromRGB(255, 70, 90),
        ButtonHover = Color3.fromRGB(30, 30, 38),

        Error = Color3.fromRGB(255, 80, 80),
        Success = Color3.fromRGB(80, 220, 160),
        Discord = Color3.fromRGB(88, 101, 242)
    },

    Service = "redexecutor",
    SilentMode = false,
    DiscordInvite = "hMVyXBx8tF",
    WebsiteURL = "https://yourwebsite.com/", -- leave like that
    FileName = "redexecutor/key.txt"
}

local function saveKey(key)
    if writefile then
        writefile(KeySystemData.FileName, key)
    end
end

local function loadSavedKey()
    if readfile and isfile and isfile(KeySystemData.FileName) then
        return readfile(KeySystemData.FileName)
    end
    return nil
end

local Lighting = game:GetService("Lighting")

local Blur = Instance.new("BlurEffect")
Blur.Name = "KeySystemBlur"
Blur.Size = 0
Blur.Parent = Lighting

SmoothTween(Blur, 0.4, { Size = 18 })

local ScreenGui = CreateObject("ScreenGui", {
    Name = "RedExecutorKeySystem", 
    Parent = CoreGui, 
    ResetOnSpawn = false,
    ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
    DisplayOrder = 999
})
local function ButtonBurst(button)
    local burstCount = math.random(8, 12)

    local centerX = button.AbsolutePosition.X + button.AbsoluteSize.X / 2
    local centerY = button.AbsolutePosition.Y + button.AbsoluteSize.Y / 2

    for i = 1, burstCount do
        local ray = Instance.new("Frame")
        ray.Size = UDim2.new(0, 6, 0, math.random(14, 20))
        ray.AnchorPoint = Vector2.new(0.5, 1)
        ray.BackgroundColor3 = button.BackgroundColor3
        ray.BackgroundTransparency = 0
        ray.Rotation = math.random(0, 360)
        ray.Position = UDim2.fromOffset(centerX, centerY)
        ray.ZIndex = 50
        ray.Parent = ScreenGui

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = ray

        local angle = math.rad(ray.Rotation)
        local distance = math.random(30, 50)

        local targetPos = UDim2.fromOffset(
            centerX + math.cos(angle) * distance,
            centerY + math.sin(angle) * distance
        )

        TweenService:Create(
            ray,
            TweenInfo.new(0.45, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {
                Position = targetPos,
                BackgroundTransparency = 1,
                Size = UDim2.new(0, 2, 0, 8)
            }
        ):Play()

        task.delay(0.5, function()
            if ray then
                ray:Destroy()
            end
        end)
    end
end

local function AddClickImpact(button)
    local originalSize = button.Size
    local pressing = false

    button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1
        or input.UserInputType == Enum.UserInputType.Touch then
            pressing = true
            SmoothTween(button, 0.08, {
                Size = originalSize - UDim2.fromOffset(4,4)
            })
        end
    end)

    button.InputEnded:Connect(function(input)
        if pressing and (
            input.UserInputType == Enum.UserInputType.MouseButton1
            or input.UserInputType == Enum.UserInputType.Touch
        ) then
            pressing = false

            SmoothTween(button, 0.12, {
                Size = originalSize
            })

            -- 💥 BẮN TIA Ở ĐÂY
            ButtonBurst(button)
        end
    end)
end
local MainFrame = CreateObject("Frame", {
    Name = "MainFrame",
    Parent = ScreenGui,
    BackgroundColor3 = KeySystemData.Colors.Background,
    BorderColor3 = KeySystemData.Colors.InputFieldBorder,
    BorderSizePixel = 2,
    Position = UDim2.new(0.5, 0, 0.5, 0),
    AnchorPoint = Vector2.new(0.5, 0.5),
    Size = UDim2.new(0, 350, 0, 250),
    ClipsDescendants = true
})

-- Glass overlay (dark glass)
local Glass = Instance.new("Frame")
Glass.Name = "Glass"
Glass.Parent = MainFrame
Glass.Size = UDim2.fromScale(1, 1)
Glass.Position = UDim2.new(0, 0, 0, 0)
Glass.BackgroundColor3 = Color3.fromRGB(30, 30, 35) -- xám đen nhẹ
Glass.BackgroundTransparency = 0.25 -- 0 = đục, 1 = trong suốt (0.7–0.8 là tốt)
Glass.BorderSizePixel = 0
Glass.ZIndex = 0


CreateObject("UICorner", {
    CornerRadius = UDim.new(0, 8),
    Parent = Glass
})
-- Optional gradient để tăng chiều sâu
local glassGrad = Instance.new("UIGradient")
glassGrad.Parent = Glass
glassGrad.Rotation = 90
glassGrad.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(40, 40, 45)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 25, 30))
}
local SnowLayer = Instance.new("Frame")
SnowLayer.Name = "SnowLayer"
SnowLayer.Parent = MainFrame
SnowLayer.BackgroundTransparency = 1
SnowLayer.Size = UDim2.fromScale(1, 1)
SnowLayer.Position = UDim2.new(0, 0, 0, 0)
SnowLayer.ZIndex = 1

--  chính
local MainStroke = Instance.new("UIStroke")
MainStroke.Parent = MainFrame
MainStroke.Color = Color3.fromRGB(180, 60, 70)
MainStroke.Thickness = 1
MainStroke.Transparency = 0.25

-- Stroke glow (phát sáng)
local GlowStroke = Instance.new("UIStroke")
GlowStroke.Parent = MainFrame
GlowStroke.Color = Color3.fromRGB(255, 70, 90)
GlowStroke.Thickness = 6
GlowStroke.Transparency = 0.85
GlowStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
task.spawn(function()
    while GlowStroke.Parent do
        TweenService:Create(
            GlowStroke,
            TweenInfo.new(1.2, Enum.EasingStyle.Sine),
            { Transparency = 0.9 }
        ):Play()

        task.wait(1.2)

        TweenService:Create(
            GlowStroke,
            TweenInfo.new(1.2, Enum.EasingStyle.Sine),
            { Transparency = 0.65 }
        ):Play()

        task.wait(1.2)
    end
end)

local TitleBar = CreateObject("Frame", {
    Name = "TitleBar",
    Parent = MainFrame,
    BackgroundColor3 = KeySystemData.Colors.Background,
    Size = UDim2.new(1, 0, 0, 30),
    BorderSizePixel = 0,
    Position = UDim2.new(0, 0, 0, 0)
})
CreateObject("UICorner", {
    CornerRadius = UDim.new(0, 8),
    Parent = TitleBar
})
local VersionLabel = CreateObject("TextLabel", {
    Name = "VersionLabel",
    Parent = MainFrame,
    BackgroundTransparency = 1,
    Size = UDim2.new(1, 0, 0, 14),
    Position = UDim2.new(0.5, 0, 0, 34),
    AnchorPoint = Vector2.new(0.5, 0),
    Text = "v1.0.0",
    Font = Enum.Font.Gotham,
    TextSize = 11,
    TextColor3 = Color3.fromRGB(255, 120, 120),
    TextTransparency = 0.5,
    TextXAlignment = Enum.TextXAlignment.Center
})

local CloseButton = CreateObject("TextButton", {
    Name = "CloseButton",
    Parent = TitleBar,
    BackgroundTransparency = 1,
    Position = UDim2.new(1, -8, 0.5, 0),
    Size = UDim2.new(0, 20, 0, 20),
    Text = "X",
    Font = Enum.Font.GothamBold,
    TextSize = 14,
    TextColor3 = KeySystemData.Colors.Title,
    AnchorPoint = Vector2.new(1, 0.5),
    AutoButtonColor = false
})

local Title = CreateObject("TextLabel", {
    Name = "Title",
    Parent = TitleBar,
    BackgroundTransparency = 1,
    Text = KeySystemData.Name .. " Key System",
    Position = UDim2.new(0.5, 0, 0.5, 0),
    Size = UDim2.new(0, 200, 0, 20),
    Font = Enum.Font.GothamBold,
    TextColor3 = KeySystemData.Colors.Title,
    TextSize = 16,
    TextXAlignment = Enum.TextXAlignment.Center,
    AnchorPoint = Vector2.new(0.5, 0.5)
})
local TitleStroke = Instance.new("UIStroke")
TitleStroke.Parent = Title
TitleStroke.Color = Color3.fromRGB(255, 60, 80)
TitleStroke.Thickness = 1.5
TitleStroke.Transparency = 0.6
local KeyInput = CreateObject("TextBox", {
    Name = "KeyInput",
    Parent = MainFrame,

    -- Background
    BackgroundColor3 = KeySystemData.Colors.InputField,

    -- Text
    Text = "",
    PlaceholderText = "ENTER ACCESS KEY",
    Font = Enum.Font.GothamMedium,
    TextSize = 14,
    TextColor3 = Color3.fromRGB(230, 230, 235),
    PlaceholderColor3 = Color3.fromRGB(140, 145, 160),
    TextXAlignment = Enum.TextXAlignment.Left,

    -- Layout
    Position = UDim2.new(0.5, 0, 0.3, 0),
    Size = UDim2.new(0, 280, 0, 36),
    AnchorPoint = Vector2.new(0.5, 0),
    ClipsDescendants = true,
    ClearTextOnFocus = false
})

-- Rounded corner
CreateObject("UICorner", {
    Parent = KeyInput,
    CornerRadius = UDim.new(0, 6)
})

-- Accent stroke (futuristic look)
local KeyStroke = CreateObject("UIStroke", {
    Parent = KeyInput,
    Color = KeySystemData.Colors.Accent,
    Thickness = 1,
    Transparency = 0.6
})

-- Padding
CreateObject("UIPadding", {
    Parent = KeyInput,
    PaddingLeft = UDim.new(0, 12)
})

-- Focus effects
KeyInput.Focused:Connect(function()
    SmoothTween(KeyStroke, 0.2, {
        Transparency = 0.25
    })
end)

KeyInput.FocusLost:Connect(function()
    SmoothTween(KeyStroke, 0.2, {
        Transparency = 0.6
    })
end)
task.spawn(function()
    local savedKey = loadSavedKey()
    if savedKey and savedKey ~= "" then
        KeyInput.Text = savedKey
    end
end)

local SubmitButton = CreateObject("TextButton", {
    Name = "ValidateButton",
    Parent = MainFrame,
    BackgroundColor3 = KeySystemData.Colors.Button,
    BorderColor3 = KeySystemData.Colors.InputFieldBorder,
    BorderSizePixel = 1,
    Position = UDim2.new(0.3, 0, 0.55, 0),
    Size = UDim2.new(0, 110, 0, 32),
    Text = "Check Key",
    Font = Enum.Font.GothamBold,
    TextSize = 14,
    TextColor3 = KeySystemData.Colors.Title,
    AutoButtonColor = false,
    AnchorPoint = Vector2.new(0.5, 0)
})
CreateObject("UICorner", {CornerRadius = UDim.new(0, 6), Parent = SubmitButton})
local SubmitDefaultColor = SubmitButton.BackgroundColor3

SubmitButton.BackgroundColor3 = KeySystemData.Colors.Accent
SubmitButton.TextColor3 = Color3.fromRGB(255,255,255)
SubmitButton.BorderSizePixel = 0

local GetKeyButton = CreateObject("TextButton", {
    Name = "GetKeyButton",
    Parent = MainFrame,
    BackgroundColor3 = KeySystemData.Colors.Button, -- nền nút
    BorderColor3 = KeySystemData.Colors.InputFieldBorder, -- viền mặc định
    BorderSizePixel = 1,
    Position = UDim2.new(0.7, 0, 0.55, 0),
    Size = UDim2.new(0, 110, 0, 32),
    Text = "Get Key",
    Font = Enum.Font.GothamBold,
    TextSize = 14,
    TextColor3 = Color3.fromRGB(255,255,255),      -- chữ trắng
    AutoButtonColor = false,
    AnchorPoint = Vector2.new(0.5, 0)
})
CreateObject("UICorner", {CornerRadius = UDim.new(0, 6), Parent = GetKeyButton})

GetKeyButton.BackgroundColor3 = KeySystemData.Colors.Button
GetKeyButton.TextColor3 = Color3.fromRGB(255,255,255)
GetKeyButton.BorderSizePixel = 1
GetKeyButton.BorderColor3 = KeySystemData.Colors.Accent

local DiscordButton = CreateObject("TextButton", {
    Name = "DiscordButton",
    Parent = MainFrame,
    BackgroundColor3 = KeySystemData.Colors.Discord,
    Position = UDim2.new(0.5, 0, 0.75, 0),
    Size = UDim2.new(0, 220, 0, 32),
    Text = "Join Discord",
    Font = Enum.Font.GothamBold,
    TextSize = 14,
    TextColor3 = Color3.fromRGB(255, 255, 255),
    AutoButtonColor = false,
    AnchorPoint = Vector2.new(0.5, 0)
})
CreateObject("UICorner", {CornerRadius = UDim.new(0, 6), Parent = DiscordButton})
AddClickImpact(SubmitButton)
AddClickImpact(GetKeyButton)
AddClickImpact(DiscordButton)

local StatusLabel = CreateObject("TextLabel", {
    Name = "StatusLabel",
    Parent = MainFrame,
    BackgroundTransparency = 1,
    Position = UDim2.new(0.5, 0, 0.9, 0),
    Size = UDim2.new(0, 280, 0, 20),
    Font = Enum.Font.Gotham,
    Text = "",
    TextColor3 = KeySystemData.Colors.Error,
    TextSize = 12,
    TextXAlignment = Enum.TextXAlignment.Center,
    AnchorPoint = Vector2.new(0.5, 0),
    TextTransparency = 1
})

local function ShowStatusMessage(text, color)
    StatusLabel.Text = text
    StatusLabel.TextColor3 = color
    StatusLabel.TextTransparency = 0
    SmoothTween(StatusLabel, 0.3, {TextTransparency = 0})
    
    task.spawn(function()
        task.wait(3)
        if StatusLabel.Text == text then
            SmoothTween(StatusLabel, 0.5, {TextTransparency = 1})
        end
    end)
end

local function closeGUI()
    local closeTween = SmoothTween(MainFrame, 0.4, {
        Size = UDim2.new(0, 0, 0, 0),
        Position = UDim2.new(0.55, 0, 0.45, 0),
        BackgroundTransparency = 1
    })

    for _, child in pairs(MainFrame:GetDescendants()) do
        if child:IsA("TextLabel") or child:IsA("TextButton") or child:IsA("TextBox") then
            SmoothTween(child, 0.25, { TextTransparency = 1 })
        end
        if child:IsA("GuiObject") and child.BackgroundTransparency < 1 then
            SmoothTween(child, 0.25, { BackgroundTransparency = 1 })
        end
        if child:IsA("UIStroke") then
            SmoothTween(child, 0.25, { Transparency = 1 })
        end
    end

    if Blur then
        SmoothTween(Blur, 0.3, { Size = 0 })
    end

    closeTween.Completed:Connect(function()
        if Blur then
            Blur:Destroy()
        end
        ScreenGui:Destroy()
    end)
end

CloseButton.MouseButton1Click:Connect(function()
    closeGUI()
end)
local function AddHoverEffect(button)
    local isDiscord = button.Name == "DiscordButton"

    button.MouseEnter:Connect(function()
        SmoothTween(button, 0.2, {
            BackgroundColor3 = KeySystemData.Colors.ButtonHover
        })
    end)

    button.MouseLeave:Connect(function()
        SmoothTween(button, 0.2, {
            BackgroundColor3 = isDiscord 
                and KeySystemData.Colors.Discord 
                or KeySystemData.Colors.Button
        })
    end)
end
AddHoverEffect(DiscordButton)
AddHoverEffect(SubmitButton)
AddHoverEffect(GetKeyButton)

local function openGetKey()
    local JunkieKeySystem = loadstring(game:HttpGet("https://junkie-development.de/sdk/JunkieKeySystem.lua"))()
    
    local API_KEY = Config.api
    local PROVIDER = Config.provider
    local SERVICE = Config.service
    
    local link = JunkieKeySystem.getLink(API_KEY, PROVIDER, SERVICE)
    if link then
        if setclipboard then
            setclipboard(link)
            ShowStatusMessage("Verification link copied!", KeySystemData.Colors.Success)
        else
            ShowStatusMessage("Link: " .. link, KeySystemData.Colors.Success)
        end
    else
        ShowStatusMessage("Failed to generate link", KeySystemData.Colors.Error)
    end
end


local function ShakeFrame(frame)
    local originalPos = frame.Position

    SmoothTween(frame, 0.05, {
        Position = originalPos + UDim2.fromOffset(6, 0)
    })
    task.wait(0.05)

    SmoothTween(frame, 0.05, {
        Position = originalPos - UDim2.fromOffset(6, 0)
    })
    task.wait(0.05)

    SmoothTween(frame, 0.05, {
        Position = originalPos
    })
end
local function validateKey()
    if isChecking then return end
    isChecking = true

    local userKey = KeyInput.Text:gsub("%s+", "")
    if userKey == "" then
        ShowStatusMessage("Please enter a key.", KeySystemData.Colors.Error)
        isChecking = false
        return
    end

    SubmitButton.BackgroundColor3 = KeySystemData.Colors.Accent

    local JunkieKeySystem = loadstring(game:HttpGet("https://junkie-development.de/sdk/JunkieKeySystem.lua"))()
    local isValid = JunkieKeySystem.verifyKey(Config.api, userKey, Config.service)

    if isValid then
        saveKey(userKey)
        ShowStatusMessage("Key valid! Loading...", KeySystemData.Colors.Success)
        task.wait(1)
        closeGUI()
        main()
    else
        ShowStatusMessage("Invalid key!", KeySystemData.Colors.Error)
        ShakeFrame(MainFrame)
        SmoothTween(SubmitButton, 0.25, {
            BackgroundColor3 = KeySystemData.Colors.Button
        })
    end

    isChecking = false
end

SubmitButton.MouseButton1Click:Connect(validateKey)
GetKeyButton.MouseButton1Click:Connect(openGetKey)
task.spawn(function()
    while VersionLabel.Parent do
        TweenService:Create(
            VersionLabel,
            TweenInfo.new(1.2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
            { TextTransparency = 0.4 }
        ):Play()

        task.wait(1.2)

        TweenService:Create(
            VersionLabel,
            TweenInfo.new(1.2, Enum.EasingStyle.Sine, Enum.EasingDirection.In),
            { TextTransparency = 1 }
        ):Play()

        task.wait(1.2)
    end
end)

local dragging = false
local dragInput
local dragStart
local startPos

local function updateDrag(input)
    local delta = input.Position - dragStart
    MainFrame.Position = UDim2.new(
        startPos.X.Scale,
        startPos.X.Offset + delta.X,
        startPos.Y.Scale,
        startPos.Y.Offset + delta.Y
    )
end

MainFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 
    or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

MainFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement 
    or input.UserInputType == Enum.UserInputType.Touch then
        if dragging then
            updateDrag(input)
        end
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        updateDrag(input)
    end
end)
DiscordButton.MouseButton1Click:Connect(function()
    local discordUrl = "https://discord.gg/" .. KeySystemData.DiscordInvite
    
    if setclipboard then
        setclipboard(discordUrl)
        ShowStatusMessage("Copied Discord invite!", Color3.fromRGB(123, 48, 220))
    else
        ShowStatusMessage("Join: " .. discordUrl, Color3.fromRGB(123, 48, 220))
    end
end)

local SnowFolder = Instance.new("Folder")
SnowFolder.Name = "Snowflakes"
SnowFolder.Parent = SnowLayer

-- 🎄 Noel assets
local snowAssets = {
    Snow = "rbxassetid://73982236676952",      -- ❄️ Tuyết
    Star = "rbxassetid://76247511279897",     -- ⭐ Ngôi sao
    Gift = "rbxassetid://122427828955075",      -- 🎁 Hộp quà
    Tree = "rbxassetid://73234983261495"      -- 🎄 Cây thông  
}
local function spawnSnowflake()
    local size = math.random(18, 32)

    local flake = Instance.new("ImageLabel")
    flake.BackgroundTransparency = 1
    flake.ImageTransparency = 0
    flake.AnchorPoint = Vector2.new(0.5, 0.5)
    flake.ScaleType = Enum.ScaleType.Fit
    flake.ZIndex = 1
    flake.Parent = SnowFolder

    -- 🎲 Chọn loại (Winter Mix)
    local roll = math.random(1, 100)

    if roll <= 85 then
        flake.Image = snowAssets.Snow       -- ❄️ 85%
    elseif roll <= 90 then
        flake.Image = snowAssets.Star       -- ⭐ 5%
    elseif roll <= 95 then
        flake.Image = snowAssets.Gift       -- 🎁 5%
    else
        flake.Image = snowAssets.Tree       -- 🎄 5%
    end

    flake.Size = UDim2.new(0, size, 0, size)

    -- Spawn X trong frame
    local xPos = math.random(5, 95) / 100
    flake.Position = UDim2.new(xPos, 0, 0.02, 0)

    -- Gió nhẹ
    local drift = math.random(-10, 10) / 100
    local targetX = math.clamp(xPos + drift, 0.05, 0.95)

    -- Thời gian rơi theo loại
    local totalTime = math.random(5, 9)
    if flake.Image == snowAssets.Tree then
        totalTime += 3
    elseif flake.Image == snowAssets.Gift then
        totalTime += 2
    elseif flake.Image == snowAssets.Star then
        totalTime += 1
    end

    -- Rơi chính (80%)
    local fallTween = TweenService:Create(
        flake,
        TweenInfo.new(totalTime * 0.8, Enum.EasingStyle.Linear),
        {
            Position = UDim2.new(targetX, 0, 0.85, 0)
        }
    )
    fallTween:Play()

    -- Fade + rơi nốt (20%)
    fallTween.Completed:Connect(function()
        if not flake.Parent then return end

        local fadeTween = TweenService:Create(
            flake,
            TweenInfo.new(totalTime * 0.2, Enum.EasingStyle.Linear),
            {
                Position = UDim2.new(targetX, 0, 0.95, 0),
                ImageTransparency = 1
            }
        )
        fadeTween:Play()

        fadeTween.Completed:Connect(function()
            if flake.Parent then
                flake:Destroy()
            end
        end)
    end)

    -- ⭐ Sao lấp lánh
    if flake.Image == snowAssets.Star then
        task.spawn(function()
            while flake.Parent do
                TweenService:Create(
                    flake,
                    TweenInfo.new(0.7),
                    { ImageTransparency = 0.2 }
                ):Play()
                task.wait(0.7)
                TweenService:Create(
                    flake,
                    TweenInfo.new(0.7),
                    { ImageTransparency = 0 }
                ):Play()
                task.wait(0.7)
            end
        end)
    end

    -- 🎄 Cây thông xoay chậm
    if flake.Image == snowAssets.Tree then
        task.spawn(function()
            while flake.Parent do
                flake.Rotation += 0.3
                task.wait(0.03)
            end
        end)
    else
        -- ❄️ Tuyết / 🎁 xoay nhẹ
        local rotationSpeed = math.random(-15, 15) * 0.6
        task.spawn(function()
            while flake.Parent do
                flake.Rotation += rotationSpeed
                task.wait(0.05)
            end
        end)
    end
end

-- Spawn loop
task.spawn(function()
    while MainFrame.Parent do
        spawnSnowflake()
        task.wait(0.45)
    end
end)


KeyInput.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        validateKey()
    end
end)

MainFrame.Position = UDim2.new(0.5, 0, 0.4, 0)
MainFrame.Size = UDim2.new(0, 0, 0, 0)
MainFrame.BackgroundTransparency = 1

SmoothTween(MainFrame, 0.5, {
    Size = UDim2.new(0, 350, 0, 250), 
    Position = UDim2.new(0.5, 0, 0.5, 0),
    BackgroundTransparency = 1
})
task.delay(0.3, function()
    local savedKey = loadSavedKey()
    if savedKey and savedKey ~= "" then
        validateKey()
    end
end)
