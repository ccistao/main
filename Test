-- Auto Hack PC Script for Flee the Facility
-- Final Version with GUI Toggle - FIXED

local player = game.Players.LocalPlayer
local Players = game:GetService("Players")
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local Replicated = game:GetService("ReplicatedStorage")

-- Settings
local scriptEnabled = false
local hackExtraPC = false -- Toggle hack extra PC
local hackDelay = 5
local waitBeforeHack = 1
local currentPC = nil
local isHacking = false
local hackedPCs = {}
local beast = nil
local foundBeast = false
local skipCurrentPC = false

-- H√†m log
local function log(message)
    print("[AUTO HACK] " .. tostring(message))
end

-- H√†m ki·ªÉm tra player c√≥ ph·∫£i Beast kh√¥ng
local function isBeast(plr)
    if not plr then return false end
    local s = plr:FindFirstChild("TempPlayerStatsModule")
    return s and s:FindFirstChild("IsBeast") and s.IsBeast.Value
end

-- H√†m t√¨m Beast
local function findBeast()
    task.spawn(function()
        local runningScan = false
        if runningScan then return end
        runningScan = true
        
        while task.wait(0.05) do
            if foundBeast then
                if not beast or not Players:FindFirstChild(beast.Name) or not isBeast(beast) then
                    beast, foundBeast = nil, false
                    log("‚ö†Ô∏è Beast ƒë√£ m·∫•t!")
                end
            end
            
            if not foundBeast then
                for _, p in ipairs(Players:GetPlayers()) do
                    if isBeast(p) then
                        beast, foundBeast = p, true
                        log("üëπ PH√ÅT HI·ªÜN BEAST: " .. beast.Name)
                        break
                    end
                end
            end
        end
    end)
end

-- H√†m ki·ªÉm tra Beast c√≥ g·∫ßn kh√¥ng (20 studs)
local function isBeastNearby()
    if not foundBeast or not beast or not beast.Character then return false end
    
    local beastRoot = beast.Character:FindFirstChild("HumanoidRootPart")
    if not beastRoot or not rootPart then return false end
    
    local distance = (rootPart.Position - beastRoot.Position).Magnitude
    return distance <= 20
end

-- H√†m tr·ªën Beast (tp xu·ªëng ƒë·∫•t -35)
local function escapeBeast()
    log("üö® BEAST ·ªû G·∫¶N! TR·ªêN XU·ªêNG ƒê·∫§T!")
    
    local currentPos = rootPart.CFrame.Position
    rootPart.CFrame = CFrame.new(currentPos.X, currentPos.Y - 35, currentPos.Z)
    
    skipCurrentPC = true
    
    log("‚è≥ Ch·ªù 2s...")
    task.wait(2)
    
    log("‚úì An to√†n! T√¨m PC kh√°c...")
end

-- Auto interact ch·ªâ cho PC
spawn(function()
    local playerGui = player:WaitForChild("PlayerGui")
    local screenGui = playerGui:WaitForChild("ScreenGui")
    local actionBox = screenGui:WaitForChild("ActionBox")
    
    actionBox:GetPropertyChangedSignal("Visible"):Connect(function()
        if scriptEnabled and actionBox.Visible then
            if isHacking and currentPC then
                log("üîß Auto interact PC!")
                game.ReplicatedStorage.RemoteEvent:FireServer("Input", "Action", true)
            end
        end
    end)
    
    log("‚úì Auto interact loaded")
end)

-- H√†m ch·ªù game active
local function waitForGameActive()
    log("ƒêang ch·ªù game active...")
    local gameActive = Replicated:WaitForChild("IsGameActive", 10)
    
    if gameActive and gameActive:IsA("BoolValue") then
        repeat 
            task.wait(0.5) 
        until gameActive.Value == true
        
        log("‚úì Game ƒë√£ active!")
        return true
    else
        log("‚úó Kh√¥ng t√¨m th·∫•y IsGameActive")
        return false
    end
end

-- H√†m check c√≥ ph·∫£i "Find an Exit" kh√¥ng
local function isFindExitPhase()
    local gameStatus = Replicated:FindFirstChild("GameStatus")
    if gameStatus and gameStatus:IsA("StringValue") then
        return gameStatus.Value:upper():find("FIND AN EXIT") ~= nil
    end
    return false
end

-- H√†m t√¨m Exit/Door
local function findExit()
    log("ƒêang t√¨m Exit...")
    
    for _, obj in pairs(workspace:GetDescendants()) do
        local name = obj.Name:lower()
        
        -- T√¨m Exit, ExitDoor, Door, FreezePod, etc.
        if (name:find("exit") or name:find("door") or name:find("escape") or 
            name:find("freeze") or name:find("pod")) and obj:IsA("Model") then
            
            -- T√¨m trigger ho·∫∑c button
            local trigger = obj:FindFirstChild("Trigger") or 
                           obj:FindFirstChild("Button") or
                           obj:FindFirstChild("Interact") or
                           obj:FindFirstChildWhichIsA("BasePart")
            
            if trigger and trigger:IsA("BasePart") then
                log("‚úì T√¨m th·∫•y Exit: " .. obj.Name)
                return {
                    exit = obj,
                    trigger = trigger,
                    position = trigger.Position
                }
            end
        end
    end
    
    log("‚úó Kh√¥ng t√¨m th·∫•y Exit!")
    return nil
end

-- H√†m m·ªü Exit
local function openExit(exitData)
    if not exitData or not exitData.trigger then return false end
    
    log("=== M·ªû C·ª¨A EXIT ===")
    
    -- TP ƒë·∫øn c·ª≠a
    log("Teleporting to exit...")
    rootPart.CFrame = exitData.trigger.CFrame + Vector3.new(0, 3, 0)
    task.wait(0.5)
    
    -- K√≠ch ho·∫°t m·ªü c·ª≠a (gi·ªëng hack PC)
    log("ƒêang m·ªü c·ª≠a...")
    local openStartTime = tick()
    local maxOpenTime = 30 -- T·ªëi ƒëa 30s ƒë·ªÉ m·ªü c·ª≠a
    
    while scriptEnabled and (tick() - openStartTime < maxOpenTime) do
        -- Fire remote ƒë·ªÉ m·ªü
        pcall(function()
            game.ReplicatedStorage.RemoteEvent:FireServer("Input", "Action", true)
        end)
        
        -- Touch trigger
        pcall(function()
            firetouchinterest(exitData.trigger, rootPart, 0)
            task.wait(0.05)
            firetouchinterest(exitData.trigger, rootPart, 1)
        end)
        
        -- Check ActionProgress ƒë·ªÉ bi·∫øt ƒë√£ m·ªü ch∆∞a
        local actionProgress = player:FindFirstChild("TempPlayerStatsModule")
        if actionProgress then
            local progress = actionProgress:FindFirstChild("ActionProgress")
            if progress and progress:IsA("NumberValue") then
                local percent = math.floor(progress.Value * 100)
                if percent % 20 == 0 then -- Log m·ªói 20%
                    log("Ti·∫øn ƒë·ªô m·ªü c·ª≠a: " .. percent .. "%")
                end
                
                -- N·∫øu >= 95% coi nh∆∞ xong
                if progress.Value >= 0.95 then
                    log("‚úì C·ª≠a ƒë√£ m·ªü!")
                    task.wait(0.5)
                    return true
                end
            end
        end
        
        task.wait(0.3)
    end
    
    log("‚è±Ô∏è Timeout m·ªü c·ª≠a, th·ª≠ escape...")
    return true -- V·∫´n cho escape ƒë·ªÉ kh√¥ng b·ªã k·∫πt
end

-- H√†m tho√°t qua c·ª≠a
local function escapeExit(exitData)
    if not exitData or not exitData.trigger then return false end
    
    log("=== THO√ÅT QUA C·ª¨A ===")
    
    -- TP v·ªÅ tr∆∞·ªõc c·ª≠a 5 studs
    local exitPos = exitData.trigger.Position
    local direction = (exitData.trigger.CFrame.LookVector * -5) -- 5 studs tr∆∞·ªõc c·ª≠a
    local escapePos = exitPos + direction
    
    log("TP v·ªÅ tr∆∞·ªõc c·ª≠a 5 studs...")
    rootPart.CFrame = CFrame.new(escapePos.X, exitPos.Y, escapePos.Z)
    task.wait(1)
    
    log("‚úÖ THO√ÅT TH√ÄNH C√îNG!")
    return true
end

-- H√†m auto t√¨m v√† tho√°t Exit
local function autoExit()
    if not scriptEnabled then return end
    
    log("üö™ B·∫ÆT ƒê·∫¶U AUTO EXIT!")
    
    -- T√¨m Exit
    local exitData = findExit()
    if not exitData then
        log("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y Exit, b·ªè qua...")
        return
    end
    
    -- M·ªü c·ª≠a
    if not openExit(exitData) then
        log("‚ö†Ô∏è Kh√¥ng m·ªü ƒë∆∞·ª£c c·ª≠a!")
        return
    end
    
    -- Tho√°t
    escapeExit(exitData)
    
    log("‚úÖ HO√ÄN T·∫§T AUTO EXIT!")
end
local function isValidPC(pc)
    if not pc then return false end

    -- 1Ô∏è‚É£ Lo·∫°i PC dev theo t√™n (QUAN TR·ªåNG)
    local name = pc.Name:lower()
    if name:find("prefab") or name:find("dev") or name:find("test") then
        log("  ‚úó B·ªè qua PC dev: " .. pc.Name)
        return false
    end

    -- 2Ô∏è‚É£ PC th·∫≠t ph·∫£i c√≥ Trigger
    local hasTrigger = false
    for _, child in pairs(pc:GetChildren()) do
        if child:IsA("BasePart") and child.Name:match("ComputerTrigger") then
            hasTrigger = true
            break
        end
    end
    
    if not hasTrigger then
        log("  ‚úó Kh√¥ng c√≥ trigger: " .. pc.Name)
        return false
    end

    log("  ‚úì PC h·ª£p l·ªá: " .. pc.Name)
    return true
end

-- H√†m t√¨m t·∫•t c·∫£ PC triggers
local function findAllPCTriggers()
    local pcGroups = {}
    local allPCs = {}

    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") and 
           (obj.Name == "ComputerTrigger1" or 
            obj.Name == "ComputerTrigger2" or 
            obj.Name == "ComputerTrigger3") then
      
            local computer = obj.Parent
            if computer then
                if not pcGroups[computer] then
                    pcGroups[computer] = { computer = computer, triggers = {} }
                end
                table.insert(pcGroups[computer].triggers, obj)
            end
        end
    end

    for comp, data in pairs(pcGroups) do
        if isValidPC(comp) and not hackedPCs[comp] then
            table.insert(allPCs, {
                trigger = data.triggers[1],
                computer = comp,
                id = comp
            })
        end
    end

    return allPCs
end

-- H√†m ki·ªÉm tra PC done
local function isPCDone(pcData)
    if not pcData or not pcData.computer then return false end
    
    for _, child in pairs(pcData.computer:GetChildren()) do
        if (child.Name == "ActionProgress" or child.Name == "Value") and 
           (child:IsA("IntValue") or child:IsA("NumberValue")) then
            if child.Value >= 1 then
                return true
            end
        end
    end
    
    for _, child in pairs(pcData.computer:GetDescendants()) do
        if (child.Name == "ActionProgress" or child.Name == "Value") and 
           (child:IsA("IntValue") or child:IsA("NumberValue")) then
            if child.Value >= 1 then
                return true
            end
        end
    end
    
    return false
end

-- H√†m theo d√µi progress
local function trackPCProgress(pcData)
    if not pcData or not pcData.computer then return end
    
    for _, child in pairs(pcData.computer:GetDescendants()) do
        if child.Name == "ActionProgress" or child.Name == "Value" then
            if child:IsA("IntValue") or child:IsA("NumberValue") then
                log("üìä Tracking: " .. child:GetFullName())
                
                child:GetPropertyChangedSignal("Value"):Connect(function()
                    local progress = math.floor(child.Value * 100)
                    log("Progress: " .. progress .. "%")
                    
                    if child.Value >= 1 then
                        log("‚úÖ PC DONE!")
                    end
                end)
            end
        end
    end
end

-- H√†m teleport
local function teleportToTrigger(triggerPart)
    if not triggerPart or not rootPart then return false end
    
    log("Teleporting to: " .. triggerPart.Name)
    rootPart.CFrame = triggerPart.CFrame + Vector3.new(0, 3, 0)
    task.wait(0.5)
    return true
end

-- H√†m k√≠ch ho·∫°t hack
local function activateHack(pcData)
    if not pcData or not pcData.trigger then return false end
    
    log("K√≠ch ho·∫°t hack (FireServer)...")
    
    pcall(function()
        game.ReplicatedStorage.RemoteEvent:FireServer("Input", "Action", true)
    end)
    
    pcall(function()
        firetouchinterest(pcData.trigger, rootPart, 0)
        task.wait(0.05)
        firetouchinterest(pcData.trigger, rootPart, 1)
    end)
    
    return true
end

-- H√†m hack PC
local function hackPC(pcData)
    if not pcData or isHacking then return end
    
    if isPCDone(pcData) then
        log("‚è≠Ô∏è PC " .. pcData.computer.Name .. " ƒë√£ done, skip!")
        hackedPCs[pcData.id] = true
        return
    end
    
    isHacking = true
    currentPC = pcData
    skipCurrentPC = false
    log("=== B·∫ÆT ƒê·∫¶U HACK PC: " .. pcData.computer.Name .. " ===")
    
    trackPCProgress(pcData)
    
    if not teleportToTrigger(pcData.trigger) then
        log("‚úó Teleport th·∫•t b·∫°i!")
        isHacking = false
        currentPC = nil
        return
    end
    
    if isPCDone(pcData) then
        log("‚è≠Ô∏è PC v·ª´a ƒë∆∞·ª£c hack xong, skip!")
        hackedPCs[pcData.id] = true
        isHacking = false
        currentPC = nil
        return
    end
    
    task.wait(waitBeforeHack)
    
    log("K√≠ch ho·∫°t hack l·∫ßn ƒë·∫ßu...")
    activateHack(pcData)
    
    local maxHackTime = 60
    local hackStartTime = tick()
    local lastJumpTime = tick()
    local checkInterval = 0
    
    while scriptEnabled and not isPCDone(pcData) and not skipCurrentPC and (tick() - hackStartTime < maxHackTime) do
        if isBeastNearby() then
            escapeBeast()
            break
        end
        
        checkInterval = checkInterval + 1
        if checkInterval >= 2 then
            if isPCDone(pcData) then
                log("‚úì PC done trong khi hack!")
                break
            end
            checkInterval = 0
        end
        
        if tick() - lastJumpTime >= hackDelay then
            log("Jumping...")
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            task.wait(0.3)
            
            rootPart.CFrame = pcData.trigger.CFrame + Vector3.new(0, 3, 0)
            task.wait(0.2)
            
            log("K√≠ch ho·∫°t hack sau jump...")
            activateHack(pcData)
            
            lastJumpTime = tick()
        end
        
        task.wait(0.5)
    end
    
    if skipCurrentPC then
        log("=== ‚ö†Ô∏è B·ªé PC N√ÄY (Beast g·∫ßn)! ===")
    elseif isPCDone(pcData) then
        log("=== ‚úÖ PC HO√ÄN T·∫§T! ===")
        hackedPCs[pcData.id] = true
    else
        log("=== ‚è±Ô∏è TIMEOUT! ===")
    end
    
    isHacking = false
    currentPC = nil
    task.wait(0.5)
end

-- Main loop
local function mainLoop()
    log("üöÄ AUTO HACK ƒêANG CH·∫†Y!")
    
    while true do
        if scriptEnabled then
            if not waitForGameActive() then
                task.wait(10)
            else
                hackedPCs = {}
                log("üÜï Game m·ªõi! Reset PC list")
                log("Hack Extra PC: " .. (hackExtraPC and "B·∫¨T" or "T·∫ÆT"))
                
                -- PHASE 1: HACK PC
                local allPCs = findAllPCTriggers()
                
                if #allPCs == 0 then
                    log("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y PC!")
                    task.wait(3)
                else
                    log("T√¨m th·∫•y " .. #allPCs .. " PC(s)")
                    
                    for _, pcData in ipairs(allPCs) do
                        if not scriptEnabled then break end
                        
                        -- LOGIC M·ªöI: Check n·∫øu chuy·ªÉn sang Find Exit
                        if isFindExitPhase() then
                            if hackExtraPC then
                                log("‚ö†Ô∏è ƒê√£ chuy·ªÉn sang Find Exit, nh∆∞ng Hack Extra PC ƒëang B·∫¨T ‚Üí ti·∫øp t·ª•c hack!")
                                -- Ti·∫øp t·ª•c hack PC c√≤n l·∫°i
                            else
                                log("‚ö†Ô∏è ƒê√£ chuy·ªÉn sang Find Exit, d·ª´ng hack PC!")
                                break -- D·ª´ng hack, chuy·ªÉn sang exit
                            end
                        end
                        
                        hackPC(pcData)
                    end
                    
                    log("‚úÖ Ho√†n t·∫•t hack PC!")
                end
                
                -- PHASE 2: FIND AND EXIT
                if hackExtraPC then
                    log("Hack Extra PC B·∫¨T ‚Üí ƒê·ª£i hack h·∫øt t·∫•t c·∫£ PC...")
                    -- ƒê·ª£i th√™m ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o hack xong h·∫øt
                    task.wait(2)
                end
                
                log("ƒê·ª£i chuy·ªÉn sang Find Exit...")
                local waitStart = tick()
                repeat
                    task.wait(0.5)
                until isFindExitPhase() or (tick() - waitStart > 30)
                
                if isFindExitPhase() then
                    log("‚úì Ph√°t hi·ªán Find Exit phase!")
                    task.wait(1) -- Ch·ªù Exit spawn
                    autoExit()
                else
                    log("‚ö†Ô∏è Kh√¥ng ph√°t hi·ªán Find Exit phase")
                end
                
                log("üéâ ROUND HO√ÄN T·∫§T! Ch·ªù game m·ªõi...")
            end
        else
            task.wait(2)
        end
    end
end

-- T·∫°o GUI Toggle Button
local function createGUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AutoHackGUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = player:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 100)
    frame.Position = UDim2.new(0.5, -100, 0, 20)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    frame.Parent = screenGui
    
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = frame
    
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 25)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundTransparency = 1
    title.Text = "AUTO HACK PC"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextSize = 14
    title.Font = Enum.Font.GothamBold
    title.Parent = frame
    
    -- Button ch√≠nh: Toggle Auto Hack
    local toggleButton = Instance.new("TextButton")
    toggleButton.Size = UDim2.new(0, 160, 0, 35)
    toggleButton.Position = UDim2.new(0.5, -80, 0, 30)
    toggleButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50)
    toggleButton.Text = "T·∫ÆT"
    toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleButton.TextSize = 16
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.Parent = frame
    
    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 6)
    btnCorner.Parent = toggleButton
    
    -- Checkbox: Hack Extra PC (nh·ªè g·ªçn)
    local checkboxFrame = Instance.new("Frame")
    checkboxFrame.Size = UDim2.new(0, 160, 0, 20)
    checkboxFrame.Position = UDim2.new(0.5, -80, 0, 72)
    checkboxFrame.BackgroundTransparency = 1
    checkboxFrame.Parent = frame
    
    -- Checkbox box
    local checkbox = Instance.new("Frame")
    checkbox.Size = UDim2.new(0, 16, 0, 16)
    checkbox.Position = UDim2.new(0, 0, 0.5, -8)
    checkbox.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    checkbox.BorderSizePixel = 1
    checkbox.BorderColor3 = Color3.fromRGB(120, 120, 120)
    checkbox.Parent = checkboxFrame
    
    local checkCorner = Instance.new("UICorner")
    checkCorner.CornerRadius = UDim.new(0, 3)
    checkCorner.Parent = checkbox
    
    -- Checkmark (·∫©n ban ƒë·∫ßu)
    local checkmark = Instance.new("TextLabel")
    checkmark.Size = UDim2.new(1, 0, 1, 0)
    checkmark.BackgroundTransparency = 1
    checkmark.Text = "‚úì"
    checkmark.TextColor3 = Color3.fromRGB(255, 80, 80)
    checkmark.TextSize = 14
    checkmark.Font = Enum.Font.GothamBold
    checkmark.Visible = false
    checkmark.Parent = checkbox
    
    -- Label
    local checkLabel = Instance.new("TextLabel")
    checkLabel.Size = UDim2.new(1, -20, 1, 0)
    checkLabel.Position = UDim2.new(0, 22, 0, 0)
    checkLabel.BackgroundTransparency = 1
    checkLabel.Text = "Hack Extra PC"
    checkLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
    checkLabel.TextSize = 11
    checkLabel.Font = Enum.Font.Gotham
    checkLabel.TextXAlignment = Enum.TextXAlignment.Left
    checkLabel.Parent = checkboxFrame
    
    -- Clickable button (invisible)
    local checkButton = Instance.new("TextButton")
    checkButton.Size = UDim2.new(1, 0, 1, 0)
    checkButton.BackgroundTransparency = 1
    checkButton.Text = ""
    checkButton.Parent = checkboxFrame
    
    -- Toggle Auto Hack function
    toggleButton.MouseButton1Click:Connect(function()
        scriptEnabled = not scriptEnabled
        
        if scriptEnabled then
            toggleButton.BackgroundColor3 = Color3.fromRGB(50, 220, 50)
            toggleButton.Text = "B·∫¨T"
            log("‚úì AUTO HACK: B·∫¨T")
        else
            toggleButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50)
            toggleButton.Text = "T·∫ÆT"
            log("‚úó AUTO HACK: T·∫ÆT")
        end
    end)
    
    -- Toggle Checkbox function
    checkButton.MouseButton1Click:Connect(function()
        hackExtraPC = not hackExtraPC
        
        if hackExtraPC then
            checkmark.Visible = true
            checkbox.BackgroundColor3 = Color3.fromRGB(80, 40, 40)
            checkbox.BorderColor3 = Color3.fromRGB(255, 80, 80)
            checkLabel.TextColor3 = Color3.fromRGB(255, 120, 120)
            log("‚úì HACK EXTRA PC: B·∫¨T (s·∫Ω hack h·∫øt t·∫•t c·∫£ PC)")
        else
            checkmark.Visible = false
            checkbox.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
            checkbox.BorderColor3 = Color3.fromRGB(120, 120, 120)
            checkLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
            log("‚úó HACK EXTRA PC: T·∫ÆT (d·ª´ng khi ƒë·ªß)")
        end
    end)
    
    -- Draggable
    local UIS = game:GetService("UserInputService")
    local dragging = false
    local dragStart
    local startPos

    frame.InputBegan:Connect(function(input)   
        if input.UserInputType == Enum.UserInputType.MouseButton1 
        or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
        end
    end)

    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1
        or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)

    UIS.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement 
            or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
    
    log("‚úì GUI created!")
end

-- Kh·ªüi ƒë·ªông
log("===============================")
log("AUTO HACK PC - FLEE THE FACILITY")
log("===============================")
createGUI()
findBeast()
task.spawn(mainLoop)
log("‚úì Script loaded! B·∫•m n√∫t ƒë·ªÉ b·∫≠t/t·∫Øt")
log("‚úì Anti-Beast: B·∫¨T (tr·ªën khi Beast < 20 studs, tp xu·ªëng -35)")
